<html>
<head>
  <meta charset="utf-8">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/vis-network/9.1.2/dist/dist/vis-network.min.css"/>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/vis-network/9.1.2/dist/vis-network.min.js"></script>
  <title>Hit Browser</title>
  <link rel="stylesheet" href="./styles.css"/>
</head>

<body>
  <div class="card" style="width: 100%">
    <div id="mynetwork" class="card-body"></div>
  </div>

  <div id="hit-info">
    <div id="hit-name"></div>
    <div id="hit-path"></div>
    <button onclick="downloadHit()">Download</button>
  </div>

  <div id="search-box">
    <input type="text" placeholder="search">
  </div>

  <div id="loadingBar">
    <div id="outerBorder">
      <div id="text">0%</div>
      <div id="border">
        <div id="bar"></div>
      </div>
    </div>
  </div>

  <script type="text/javascript">
    const search_event = new Event("search");

    // initialize global variables.
    let edges;
    let nodes;
    let allNodes;
    let allEdges;
    let nodeColors;
    let network;
    let container;
    let options;
    let heading;
    let data;

    // This method is responsible for drawing the graph, returns the drawn network
    function drawGraph() {
      const container = document.getElementById('mynetwork');
      const hit_info = document.getElementById("hit-info");
      const hit_name = document.getElementById("hit-name");
      const hit_path = document.getElementById("hit-path");

      // parsing and collecting nodes and edges from the python
      nodes = new vis.DataSet({{nodes|tojson}});
      edges = new vis.DataSet({{edges|tojson}});

      // Add nodes to the graph.
      nodeColors = {};
      allNodes = nodes.get({returnType: "Object"});
      for (nodeId in allNodes) {
        console.log(allNodes[nodeId].color);
        nodeColors[nodeId] = allNodes[nodeId].color;
      }

      // Add edges to the graph.
      allEdges = edges.get({returnType: "Object"});

      // Load options.
      options = {{options|safe}};

      // Load heading.
      heading = {{heading|safe}};

      // Create the network.
      data = {nodes, edges};
      network = new vis.Network(container, data, options);

      console.log(nodes.get()[2].x);

      // Stabalize the network.
      network.stabilize(0);
      network.on("stabilizationProgress", function(params) {
        document.getElementById('loadingBar').removeAttribute("style");
        const maxWidth = 496;
        const minWidth = 20;
        const widthFactor = params.iterations / params.total;
        const width = Math.max(minWidth,maxWidth * widthFactor);
        document.getElementById('bar').style.width = width + 'px';
        document.getElementById('text').innerHTML = Math.round(widthFactor*100) + '%';
      });
      network.once("stabilizationIterationsDone", function() {
        hit_info.style.display = "none";
        document.getElementById('text').innerHTML = '100%';
        document.getElementById('bar').style.width = '496px';
        document.getElementById('loadingBar').style.opacity = 0;
        setTimeout(function () {
          document.getElementById('loadingBar').style.display = 'none';
        }, 500);

        nodes.forEach(function(node) {
          const new_pos = network.getPosition(node.id);
          nodes.update({id: node.id, y: new_pos.y, x: new_pos.x});
        });
      });

      // Click a hit.
      network.on('click', function(properties) {
        const ids = properties.nodes;
        const clickedNodes = nodes.get(ids);

        // Display the info.
        if (clickedNodes.length == 0) {
          hit_info.style.display = "none";
          hit_name.innerHTML = "";
          hit_path.innerHTML = "";
        } else {
          hit_info.style.display = "initial";
          const file_path = clickedNodes[0]['path']
          const audio = new Audio(heading.root_path + file_path);
          audio.play();
          hit_name.innerHTML = file_path.substring(file_path.lastIndexOf('/') + 1);
          hit_path.innerHTML = file_path;
        }
      });

      // Set min and max zoom.
      network.on("zoom", function() {
        if (network.getScale() < 0.10) {
          network.moveTo({scale: 0.10});
        } else if (network.getScale() > 1) {
          network.moveTo({scale: 1});
        }
      });

      document.querySelector("#search-box").addEventListener("change", (event) => {
        console.log(event.target.value);

        for (const nodeId in allNodes) {
          if (allNodes[nodeId].path.toLowerCase().includes(event.target.value.toLowerCase())) {
            allNodes[nodeId].color = "#97c2fc";
          } else {
            allNodes[nodeId].color = "rgba(200,200,200,0.5)";
          }
        }

        // transform the object into an array
        updateArray = [];
        for (nodeId in allNodes) {
          if (allNodes.hasOwnProperty(nodeId)) {
            updateArray.push(allNodes[nodeId]);
          }
        }
        nodes.update(updateArray);
      });

      return network;
    }

    function downloadHit() {
      const path = document.getElementById("hit-path").innerHTML;
      if (path) {
        const anchor = document.createElement('a');
        anchor.setAttribute('href', heading.root_path + path);
        // anchor.setAttribute('download', path.substring(path.lastIndexOf('/') + 1));
        anchor.setAttribute('target', "_blank");
        document.body.appendChild(anchor);
        anchor.click();
        anchor.parentNode.removeChild(anchor);
      }
    }

    drawGraph();

  </script>
</body>
</html>